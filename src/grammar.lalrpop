use crate::ast::{ParsedExpr, Literal, Id};
use crate::lexer::{LexicalError, Token};
use crate::types::{Type, TyVar, TyCon, Kind, QualType, Qual, Pred};

grammar;

extern {
  type Location = usize;
  type Error = LexicalError;

  enum Token {
    "(" => Token::LParens,
    ")" => Token::RParens,
    "let" => Token::Let,
    "in" => Token::In,
    "=" => Token::Equals,
    ":" => Token::Colon,
    "," => Token::Comma,
    "->" => Token::Arrow,
    "=>" => Token::FatArrow,
    "fun" => Token::Fun,
    "integer literal" => Token::IntegerLiteral(<i64>),
    "string literal" => Token::StringLiteral(<String>),
    "identifier" => Token::Identifier(<String>),
  }
}

// utility for comma-separated lists
CommaSeparated<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
}

pub Expr: Box<ParsedExpr> = {
    SubExpr,
    LambdaExpr,
    AppExpr,
    LetExpr,
}

SubExpr: Box<ParsedExpr> = {
    Terminal,
    "(" <e:Expr> ")" => e
}

Terminal: Box<ParsedExpr> = {
    <int:"integer literal"> => {
        Box::new(ParsedExpr::Lit(Literal::Int(int)))
    },
    <str:"string literal"> => {
        Box::new(ParsedExpr::Lit(Literal::Str(str)))
    },
    <id:"identifier"> => {
        Box::new(ParsedExpr::Var(Id::new(&id)))
    },
}

LetExpr: Box<ParsedExpr> = {
    "let" <id:"identifier"> "=" <e1:Expr> "in" <e2:Expr> => {
        Box::new(ParsedExpr::Let(Id::new(&id), e1, e2))
    }
}

Args: Vec<Id> = {
    <params:"identifier"*> => {
        params.into_iter().map(|param| Id::new(&param)).collect::<Vec<_>>()
    }
}

LambdaExpr: Box<ParsedExpr> = {
    "fun" <args:Args> "->" <body:Expr> => {
        Box::new(ParsedExpr::Lambda(args, body))
    }
}

AppExpr: Box<ParsedExpr> = {
    <e:SubExpr> <es:SubExpr+> => {
        Box::new(ParsedExpr::App(e, es))
    }
}

pub TypeExpr: Type = {
    TypeTerminal,
    TypeArrow,
    TypeApp
}

// TODO: handle both vars and constants
TypeTerminal: Type = {
    <id:"identifier"> => {
        // TODO: by default everything has Kind::Star, not sure if this is a good idea
        Type::Var(TyVar(Id::new(&id), Kind::Star))
    },
}

TypeArrow: Type = {
    <t1:TypeTerminal> "->" <t2:TypeTerminal> => {
        Type::Arrow(Box::new(t1), Box::new(t2))
    }
}

// TODO: for now we only support applications of kind * -> *
TypeApp: Type = {
    <t1:TypeTerminal> <t2:TypeTerminal> => {
        Type::App(Box::new(t1), Box::new(t2))
    }
}

// TODO: for now we don't support syntax like `Show a => a -> a`, only `(Show a) => a -> a`
pub QualTypeExpr: QualType = {
    "(" <preds:Predicates> ")" "=>" <ty:TypeExpr> => {
        Qual::new(preds, ty)
    },
    <ty:TypeExpr> => {
        Qual::new(vec![], ty)
    }
}

Predicates = CommaSeparated<Predicate>;

Predicate: Pred = {
    <class:"identifier"> <ty:TypeExpr> => {
        Pred::new(Id::new(&class), ty)
    }
}